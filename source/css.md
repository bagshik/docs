---
title: CSS stylesheets
description: Next-gen CSS with PostCSS and SASS
---

<h2 id="files">Writing CSS files</h2>

---
CSS can be written and placed anywhere. A common pattern is to write the `.css` alongside regular `.js` files, so they 'live' in the same place.

You can import and use styles in your code like regular Javascript:

Inside your CSS:

**someCssFile.css**
```css
.someClass {
  font-weight: bold;
  text-align: center;
  color: red;
}
```

**someJsFile.js**
```js
import css from './someCssFile.css';

// .someClass will get transformed into a hashed, 'local' name, to avoid
// collisions with the global namespace
export default props => (
  <div>
    <p className={css.someClass}>Hello world</p>
  </div>
)
```

<h2 id="cssnext" title="CSSNext">Next-generation CSS parsing</h2>

---
`.css` and `.sass / .scss` stylesheets are parsed through [CSSNext](http://cssnext.io/), using the default settings.

That means you can use things like nested statements out-the-box:

```css
.anotherClassName {
  & h1 {
    text-size: 2em;
  }
  & p {
    color: green;
  }
}
```

As well as variable names, and other goodies:

```css
:root {
  --mainColor: red;
}

a {
  color: var(--mainColor);
}
```

Vendor prefixes will automatically be added, so you can write the bare CSS and let PostCSS worry about polyfilling browsers.

<h2 id="sass">SASS support</h2>

---
[SASS](http://sass-lang.com/) code is also compiled through PostCSS in the same way. Simply use `.sass`/`.scss` files instead, and your stylesheets will pass through [node-sass](https://github.com/sass/node-sass) first.


<h2 id="local" title="Local modules">Local modules - preventing bleed-out</h2>

---
By default, class styles in your CSS/SASS files will be exported as _local_ modules. Class names will be hashed to prevent bleeding out to your global namespace, and those same class names are then injected into the React code that is bundled for you. e.g:

![CSS local classnames](images/classnames.png)

The benefit to this is tight coupling of style logic with your components.  You don't have to worry that you've used globally unique class names, because Webpack will transpile your names into garbled, hashed versions to avoid conflicts.

<h2 id="global_styles">Global styles</h2>

---
If you want to override the 'local by default' classnames, simply prefix `:global` before the rule and it'll be made available across your entire app:

```css
:global (.thisClassWontRename) {
  font-color: blue;
}
```

In this case, `.thisClassWontRename` will be the exact name used in the output to your final .css file, so you can use this class name wherever you want the style to apply - anywhere in your code.

<h2 id="bundling">Bundling styles</h2>

---
In development, your styles will be bundled with full source maps into the resulting Javascript that's generated by Webpack Dev Server. No external CSS file is created or called.

In production, code is extracted out into a final `style.css` file that is automatically minified and included in the first-page HTML via a `<link>` tag that's sent from the server-side.  Webpack will do the heavy lifting and match up your React names with the CSS localised styles, so it'll work exactly the same way as in dev.

You don't need to do anything for this to happen- ReactQL takes care of it for you.

<h2 id="server">Server-side support</h2>

---
CSS on the server is fully supported, so you can write your code without fear that stylesheets will break universal/server-side rendering.

In production, your styles will automatically be extracted out to a `dist/public/assets/css/style.css` and your server bundle will know the relevant 'hashed' classname to include in your `class=` attribute on your components.

This is done for you automatically - no code changes required.
